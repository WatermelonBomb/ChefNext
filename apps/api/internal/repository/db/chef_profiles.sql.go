// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chef_profiles.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createChefProfile = `-- name: CreateChefProfile :one
INSERT INTO chef_profiles (
    user_id,
    full_name,
    headline,
    summary,
    location,
    years_experience,
    availability,
    specialties,
    work_areas,
    languages,
    bio,
    learning_focus,
    skill_tree_json,
    portfolio_items
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING id, user_id, skill_tree_json, specialties, work_areas, bio, created_at, updated_at, headline, summary, location, years_experience, availability, languages, learning_focus, portfolio_items, full_name
`

type CreateChefProfileParams struct {
	UserID          pgtype.UUID
	FullName        pgtype.Text
	Headline        pgtype.Text
	Summary         pgtype.Text
	Location        pgtype.Text
	YearsExperience pgtype.Int4
	Availability    pgtype.Text
	Specialties     []string
	WorkAreas       []string
	Languages       []string
	Bio             pgtype.Text
	LearningFocus   []string
	SkillTreeJson   []byte
	PortfolioItems  []byte
}

func (q *Queries) CreateChefProfile(ctx context.Context, arg CreateChefProfileParams) (ChefProfile, error) {
	row := q.db.QueryRow(ctx, createChefProfile,
		arg.UserID,
		arg.FullName,
		arg.Headline,
		arg.Summary,
		arg.Location,
		arg.YearsExperience,
		arg.Availability,
		arg.Specialties,
		arg.WorkAreas,
		arg.Languages,
		arg.Bio,
		arg.LearningFocus,
		arg.SkillTreeJson,
		arg.PortfolioItems,
	)
	var i ChefProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SkillTreeJson,
		&i.Specialties,
		&i.WorkAreas,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Headline,
		&i.Summary,
		&i.Location,
		&i.YearsExperience,
		&i.Availability,
		&i.Languages,
		&i.LearningFocus,
		&i.PortfolioItems,
		&i.FullName,
	)
	return i, err
}

const deleteChefProfile = `-- name: DeleteChefProfile :exec
DELETE FROM chef_profiles
WHERE id = $1
`

func (q *Queries) DeleteChefProfile(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteChefProfile, id)
	return err
}

const getChefProfileByID = `-- name: GetChefProfileByID :one
SELECT id, user_id, skill_tree_json, specialties, work_areas, bio, created_at, updated_at, headline, summary, location, years_experience, availability, languages, learning_focus, portfolio_items, full_name FROM chef_profiles
WHERE id = $1
`

func (q *Queries) GetChefProfileByID(ctx context.Context, id pgtype.UUID) (ChefProfile, error) {
	row := q.db.QueryRow(ctx, getChefProfileByID, id)
	var i ChefProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SkillTreeJson,
		&i.Specialties,
		&i.WorkAreas,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Headline,
		&i.Summary,
		&i.Location,
		&i.YearsExperience,
		&i.Availability,
		&i.Languages,
		&i.LearningFocus,
		&i.PortfolioItems,
		&i.FullName,
	)
	return i, err
}

const getChefProfileByUserID = `-- name: GetChefProfileByUserID :one
SELECT id, user_id, skill_tree_json, specialties, work_areas, bio, created_at, updated_at, headline, summary, location, years_experience, availability, languages, learning_focus, portfolio_items, full_name FROM chef_profiles
WHERE user_id = $1
`

func (q *Queries) GetChefProfileByUserID(ctx context.Context, userID pgtype.UUID) (ChefProfile, error) {
	row := q.db.QueryRow(ctx, getChefProfileByUserID, userID)
	var i ChefProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SkillTreeJson,
		&i.Specialties,
		&i.WorkAreas,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Headline,
		&i.Summary,
		&i.Location,
		&i.YearsExperience,
		&i.Availability,
		&i.Languages,
		&i.LearningFocus,
		&i.PortfolioItems,
		&i.FullName,
	)
	return i, err
}

const searchChefProfiles = `-- name: SearchChefProfiles :many
SELECT id, user_id, skill_tree_json, specialties, work_areas, bio, created_at, updated_at, headline, summary, location, years_experience, availability, languages, learning_focus, portfolio_items, full_name FROM chef_profiles
WHERE
    ($1::TEXT[] IS NULL OR specialties && $1::TEXT[])
    AND ($2::TEXT[] IS NULL OR work_areas && $2::TEXT[])
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type SearchChefProfilesParams struct {
	Column1 []string
	Column2 []string
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchChefProfiles(ctx context.Context, arg SearchChefProfilesParams) ([]ChefProfile, error) {
	rows, err := q.db.Query(ctx, searchChefProfiles,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChefProfile
	for rows.Next() {
		var i ChefProfile
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SkillTreeJson,
			&i.Specialties,
			&i.WorkAreas,
			&i.Bio,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Headline,
			&i.Summary,
			&i.Location,
			&i.YearsExperience,
			&i.Availability,
			&i.Languages,
			&i.LearningFocus,
			&i.PortfolioItems,
			&i.FullName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChefProfile = `-- name: UpdateChefProfile :one
UPDATE chef_profiles
SET
    full_name = COALESCE($2, full_name),
    headline = COALESCE($3, headline),
    summary = COALESCE($4, summary),
    location = COALESCE($5, location),
    years_experience = COALESCE($6, years_experience),
    availability = COALESCE($7, availability),
    specialties = COALESCE($8, specialties),
    work_areas = COALESCE($9, work_areas),
    languages = COALESCE($10, languages),
    bio = COALESCE($11, bio),
    learning_focus = COALESCE($12, learning_focus),
    skill_tree_json = COALESCE($13, skill_tree_json),
    portfolio_items = COALESCE($14, portfolio_items),
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, skill_tree_json, specialties, work_areas, bio, created_at, updated_at, headline, summary, location, years_experience, availability, languages, learning_focus, portfolio_items, full_name
`

type UpdateChefProfileParams struct {
	ID              pgtype.UUID
	FullName        pgtype.Text
	Headline        pgtype.Text
	Summary         pgtype.Text
	Location        pgtype.Text
	YearsExperience pgtype.Int4
	Availability    pgtype.Text
	Specialties     []string
	WorkAreas       []string
	Languages       []string
	Bio             pgtype.Text
	LearningFocus   []string
	SkillTreeJson   []byte
	PortfolioItems  []byte
}

func (q *Queries) UpdateChefProfile(ctx context.Context, arg UpdateChefProfileParams) (ChefProfile, error) {
	row := q.db.QueryRow(ctx, updateChefProfile,
		arg.ID,
		arg.FullName,
		arg.Headline,
		arg.Summary,
		arg.Location,
		arg.YearsExperience,
		arg.Availability,
		arg.Specialties,
		arg.WorkAreas,
		arg.Languages,
		arg.Bio,
		arg.LearningFocus,
		arg.SkillTreeJson,
		arg.PortfolioItems,
	)
	var i ChefProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SkillTreeJson,
		&i.Specialties,
		&i.WorkAreas,
		&i.Bio,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Headline,
		&i.Summary,
		&i.Location,
		&i.YearsExperience,
		&i.Availability,
		&i.Languages,
		&i.LearningFocus,
		&i.PortfolioItems,
		&i.FullName,
	)
	return i, err
}

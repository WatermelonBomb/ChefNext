// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: applications.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications (
    job_id,
    chef_profile_id,
    status,
    cover_letter
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, job_id, chef_profile_id, status, cover_letter, created_at, updated_at
`

type CreateApplicationParams struct {
	JobID         pgtype.UUID
	ChefProfileID pgtype.UUID
	Status        ApplicationStatus
	CoverLetter   pgtype.Text
}

func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (Application, error) {
	row := q.db.QueryRow(ctx, createApplication,
		arg.JobID,
		arg.ChefProfileID,
		arg.Status,
		arg.CoverLetter,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.ChefProfileID,
		&i.Status,
		&i.CoverLetter,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getApplicationByJobAndChef = `-- name: GetApplicationByJobAndChef :one
SELECT id, job_id, chef_profile_id, status, cover_letter, created_at, updated_at
FROM applications
WHERE job_id = $1 AND chef_profile_id = $2
`

type GetApplicationByJobAndChefParams struct {
	JobID         pgtype.UUID
	ChefProfileID pgtype.UUID
}

func (q *Queries) GetApplicationByJobAndChef(ctx context.Context, arg GetApplicationByJobAndChefParams) (Application, error) {
	row := q.db.QueryRow(ctx, getApplicationByJobAndChef, arg.JobID, arg.ChefProfileID)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.ChefProfileID,
		&i.Status,
		&i.CoverLetter,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getApplicationOwnership = `-- name: GetApplicationOwnership :one
SELECT
    a.id,
    a.job_id,
    a.chef_profile_id,
    j.restaurant_id,
    rp.user_id AS restaurant_user_id,
    cp.user_id AS chef_user_id
FROM applications a
JOIN jobs j ON j.id = a.job_id
JOIN restaurant_profiles rp ON rp.id = j.restaurant_id
JOIN chef_profiles cp ON cp.id = a.chef_profile_id
WHERE a.id = $1
`

type GetApplicationOwnershipRow struct {
	ID               pgtype.UUID
	JobID            pgtype.UUID
	ChefProfileID    pgtype.UUID
	RestaurantID     pgtype.UUID
	RestaurantUserID pgtype.UUID
	ChefUserID       pgtype.UUID
}

func (q *Queries) GetApplicationOwnership(ctx context.Context, id pgtype.UUID) (GetApplicationOwnershipRow, error) {
	row := q.db.QueryRow(ctx, getApplicationOwnership, id)
	var i GetApplicationOwnershipRow
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.ChefProfileID,
		&i.RestaurantID,
		&i.RestaurantUserID,
		&i.ChefUserID,
	)
	return i, err
}

const listApplicationsForChef = `-- name: ListApplicationsForChef :many
SELECT
    a.id,
    a.job_id,
    a.chef_profile_id,
    a.status,
    a.cover_letter,
    a.created_at,
    a.updated_at,
    j.title AS job_title,
    j.status AS job_status,
    rp.display_name AS restaurant_display_name
FROM applications a
JOIN jobs j ON j.id = a.job_id
JOIN restaurant_profiles rp ON rp.id = j.restaurant_id
WHERE a.chef_profile_id = $1
ORDER BY a.created_at DESC
LIMIT $2 OFFSET $3
`

type ListApplicationsForChefParams struct {
	ChefProfileID pgtype.UUID
	Limit         int32
	Offset        int32
}

type ListApplicationsForChefRow struct {
	ID                    pgtype.UUID
	JobID                 pgtype.UUID
	ChefProfileID         pgtype.UUID
	Status                ApplicationStatus
	CoverLetter           pgtype.Text
	CreatedAt             pgtype.Timestamp
	UpdatedAt             pgtype.Timestamp
	JobTitle              string
	JobStatus             JobStatus
	RestaurantDisplayName pgtype.Text
}

func (q *Queries) ListApplicationsForChef(ctx context.Context, arg ListApplicationsForChefParams) ([]ListApplicationsForChefRow, error) {
	rows, err := q.db.Query(ctx, listApplicationsForChef, arg.ChefProfileID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListApplicationsForChefRow
	for rows.Next() {
		var i ListApplicationsForChefRow
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.ChefProfileID,
			&i.Status,
			&i.CoverLetter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.JobTitle,
			&i.JobStatus,
			&i.RestaurantDisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplicationsForRestaurant = `-- name: ListApplicationsForRestaurant :many
SELECT
    a.id,
    a.job_id,
    a.chef_profile_id,
    a.status,
    a.cover_letter,
    a.created_at,
    a.updated_at,
    cp.full_name AS chef_full_name,
    cp.location AS chef_location,
    j.title AS job_title
FROM applications a
JOIN jobs j ON j.id = a.job_id
JOIN chef_profiles cp ON cp.id = a.chef_profile_id
WHERE j.restaurant_id = $1
ORDER BY a.created_at DESC
LIMIT $2 OFFSET $3
`

type ListApplicationsForRestaurantParams struct {
	RestaurantID pgtype.UUID
	Limit        int32
	Offset       int32
}

type ListApplicationsForRestaurantRow struct {
	ID            pgtype.UUID
	JobID         pgtype.UUID
	ChefProfileID pgtype.UUID
	Status        ApplicationStatus
	CoverLetter   pgtype.Text
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
	ChefFullName  pgtype.Text
	ChefLocation  pgtype.Text
	JobTitle      string
}

func (q *Queries) ListApplicationsForRestaurant(ctx context.Context, arg ListApplicationsForRestaurantParams) ([]ListApplicationsForRestaurantRow, error) {
	rows, err := q.db.Query(ctx, listApplicationsForRestaurant, arg.RestaurantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListApplicationsForRestaurantRow
	for rows.Next() {
		var i ListApplicationsForRestaurantRow
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.ChefProfileID,
			&i.Status,
			&i.CoverLetter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChefFullName,
			&i.ChefLocation,
			&i.JobTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateApplicationStatus = `-- name: UpdateApplicationStatus :one
UPDATE applications
SET status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, job_id, chef_profile_id, status, cover_letter, created_at, updated_at
`

type UpdateApplicationStatusParams struct {
	ID     pgtype.UUID
	Status ApplicationStatus
}

func (q *Queries) UpdateApplicationStatus(ctx context.Context, arg UpdateApplicationStatusParams) (Application, error) {
	row := q.db.QueryRow(ctx, updateApplicationStatus, arg.ID, arg.Status)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.ChefProfileID,
		&i.Status,
		&i.CoverLetter,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (
    restaurant_id,
    title,
    description,
    required_skills,
    location,
    salary_range,
    employment_type,
    status,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, restaurant_id, title, description, required_skills, location, salary_range,
          employment_type, status, metadata, created_at, updated_at
`

type CreateJobParams struct {
	RestaurantID   pgtype.UUID
	Title          string
	Description    string
	RequiredSkills []string
	Location       pgtype.Text
	SalaryRange    pgtype.Text
	EmploymentType pgtype.Text
	Status         JobStatus
	Metadata       []byte
}

type CreateJobRow struct {
	ID             pgtype.UUID
	RestaurantID   pgtype.UUID
	Title          string
	Description    string
	RequiredSkills []string
	Location       pgtype.Text
	SalaryRange    pgtype.Text
	EmploymentType pgtype.Text
	Status         JobStatus
	Metadata       []byte
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (CreateJobRow, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.RestaurantID,
		arg.Title,
		arg.Description,
		arg.RequiredSkills,
		arg.Location,
		arg.SalaryRange,
		arg.EmploymentType,
		arg.Status,
		arg.Metadata,
	)
	var i CreateJobRow
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Title,
		&i.Description,
		&i.RequiredSkills,
		&i.Location,
		&i.SalaryRange,
		&i.EmploymentType,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJobByID = `-- name: GetJobByID :one
SELECT
    j.id,
    j.restaurant_id,
    j.title,
    j.description,
    j.required_skills,
    j.location,
    j.salary_range,
    j.employment_type,
    j.status,
    j.metadata,
    j.created_at,
    j.updated_at,
    rp.display_name,
    rp.tagline,
    rp.location AS restaurant_location,
    rp.user_id AS restaurant_user_id
FROM jobs j
JOIN restaurant_profiles rp ON rp.id = j.restaurant_id
WHERE j.id = $1
`

type GetJobByIDRow struct {
	ID                 pgtype.UUID
	RestaurantID       pgtype.UUID
	Title              string
	Description        string
	RequiredSkills     []string
	Location           pgtype.Text
	SalaryRange        pgtype.Text
	EmploymentType     pgtype.Text
	Status             JobStatus
	Metadata           []byte
	CreatedAt          pgtype.Timestamp
	UpdatedAt          pgtype.Timestamp
	DisplayName        pgtype.Text
	Tagline            pgtype.Text
	RestaurantLocation pgtype.Text
	RestaurantUserID   pgtype.UUID
}

func (q *Queries) GetJobByID(ctx context.Context, id pgtype.UUID) (GetJobByIDRow, error) {
	row := q.db.QueryRow(ctx, getJobByID, id)
	var i GetJobByIDRow
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Title,
		&i.Description,
		&i.RequiredSkills,
		&i.Location,
		&i.SalaryRange,
		&i.EmploymentType,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DisplayName,
		&i.Tagline,
		&i.RestaurantLocation,
		&i.RestaurantUserID,
	)
	return i, err
}

const getJobOwnership = `-- name: GetJobOwnership :one
SELECT
    j.id,
    j.restaurant_id,
    rp.user_id AS restaurant_user_id
FROM jobs j
JOIN restaurant_profiles rp ON rp.id = j.restaurant_id
WHERE j.id = $1
`

type GetJobOwnershipRow struct {
	ID               pgtype.UUID
	RestaurantID     pgtype.UUID
	RestaurantUserID pgtype.UUID
}

func (q *Queries) GetJobOwnership(ctx context.Context, id pgtype.UUID) (GetJobOwnershipRow, error) {
	row := q.db.QueryRow(ctx, getJobOwnership, id)
	var i GetJobOwnershipRow
	err := row.Scan(&i.ID, &i.RestaurantID, &i.RestaurantUserID)
	return i, err
}

const listJobsByRestaurant = `-- name: ListJobsByRestaurant :many
SELECT
    id,
    restaurant_id,
    title,
    description,
    required_skills,
    location,
    salary_range,
    employment_type,
    status,
    metadata,
    created_at,
    updated_at,
    COUNT(*) OVER() AS total_count
FROM jobs
WHERE restaurant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListJobsByRestaurantParams struct {
	RestaurantID pgtype.UUID
	Limit        int32
	Offset       int32
}

type ListJobsByRestaurantRow struct {
	ID             pgtype.UUID
	RestaurantID   pgtype.UUID
	Title          string
	Description    string
	RequiredSkills []string
	Location       pgtype.Text
	SalaryRange    pgtype.Text
	EmploymentType pgtype.Text
	Status         JobStatus
	Metadata       []byte
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
	TotalCount     int64
}

func (q *Queries) ListJobsByRestaurant(ctx context.Context, arg ListJobsByRestaurantParams) ([]ListJobsByRestaurantRow, error) {
	rows, err := q.db.Query(ctx, listJobsByRestaurant, arg.RestaurantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListJobsByRestaurantRow
	for rows.Next() {
		var i ListJobsByRestaurantRow
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.Title,
			&i.Description,
			&i.RequiredSkills,
			&i.Location,
			&i.SalaryRange,
			&i.EmploymentType,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchJobs = `-- name: SearchJobs :many
SELECT
    j.id,
    j.restaurant_id,
    j.title,
    j.description,
    j.required_skills,
    j.location,
    j.salary_range,
    j.employment_type,
    j.status,
    j.metadata,
    j.created_at,
    j.updated_at,
    rp.display_name,
    rp.tagline,
    rp.location AS restaurant_location,
    rp.user_id AS restaurant_user_id,
    COUNT(*) OVER() AS total_count
FROM jobs j
JOIN restaurant_profiles rp ON rp.id = j.restaurant_id
WHERE
    j.status = 'PUBLISHED'
    AND ($1::text IS NULL OR j.search_vector @@ plainto_tsquery('simple', $1))
    AND ($2::text[] IS NULL OR j.required_skills && $2::text[])
    AND ($3::text IS NULL OR j.location ILIKE '%' || $3 || '%')
ORDER BY j.created_at DESC
LIMIT $4 OFFSET $5
`

type SearchJobsParams struct {
	Column1 string
	Column2 []string
	Column3 string
	Limit   int32
	Offset  int32
}

type SearchJobsRow struct {
	ID                 pgtype.UUID
	RestaurantID       pgtype.UUID
	Title              string
	Description        string
	RequiredSkills     []string
	Location           pgtype.Text
	SalaryRange        pgtype.Text
	EmploymentType     pgtype.Text
	Status             JobStatus
	Metadata           []byte
	CreatedAt          pgtype.Timestamp
	UpdatedAt          pgtype.Timestamp
	DisplayName        pgtype.Text
	Tagline            pgtype.Text
	RestaurantLocation pgtype.Text
	RestaurantUserID   pgtype.UUID
	TotalCount         int64
}

func (q *Queries) SearchJobs(ctx context.Context, arg SearchJobsParams) ([]SearchJobsRow, error) {
	rows, err := q.db.Query(ctx, searchJobs,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchJobsRow
	for rows.Next() {
		var i SearchJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.Title,
			&i.Description,
			&i.RequiredSkills,
			&i.Location,
			&i.SalaryRange,
			&i.EmploymentType,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DisplayName,
			&i.Tagline,
			&i.RestaurantLocation,
			&i.RestaurantUserID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJob = `-- name: UpdateJob :one
UPDATE jobs
SET
    title = COALESCE($1, title),
    description = COALESCE($2, description),
    required_skills = COALESCE($3, required_skills),
    location = COALESCE($4, location),
    salary_range = COALESCE($5, salary_range),
    employment_type = COALESCE($6, employment_type),
    status = COALESCE($7, status),
    metadata = COALESCE($8, metadata),
    updated_at = NOW()
WHERE id = $9
RETURNING id, restaurant_id, title, description, required_skills, location, salary_range,
          employment_type, status, metadata, created_at, updated_at
`

type UpdateJobParams struct {
	Title          pgtype.Text
	Description    pgtype.Text
	RequiredSkills []string
	Location       pgtype.Text
	SalaryRange    pgtype.Text
	EmploymentType pgtype.Text
	Status         NullJobStatus
	Metadata       []byte
	ID             pgtype.UUID
}

type UpdateJobRow struct {
	ID             pgtype.UUID
	RestaurantID   pgtype.UUID
	Title          string
	Description    string
	RequiredSkills []string
	Location       pgtype.Text
	SalaryRange    pgtype.Text
	EmploymentType pgtype.Text
	Status         JobStatus
	Metadata       []byte
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (UpdateJobRow, error) {
	row := q.db.QueryRow(ctx, updateJob,
		arg.Title,
		arg.Description,
		arg.RequiredSkills,
		arg.Location,
		arg.SalaryRange,
		arg.EmploymentType,
		arg.Status,
		arg.Metadata,
		arg.ID,
	)
	var i UpdateJobRow
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.Title,
		&i.Description,
		&i.RequiredSkills,
		&i.Location,
		&i.SalaryRange,
		&i.EmploymentType,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
